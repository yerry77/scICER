#!/usr/bin/env Rscript

# Harmony Integration + scICER Clustering on Single-Cell Data
# Workflow Overview:
# 
# 1. Environment Setup:
#    - Load R libraries for Seurat, Harmony, scICER, plotting, and data handling.
#    - Python environment is optional (only if using Scanpy for other preprocessing).
#
# 2. Input/Output:
#    - Define input Seurat object file (preprocessed single-cell dataset).
#    - Define output directories and create them if they do not exist.
#
# 3. Batch Correction using Harmony:
#    - Run Harmony integration to remove batch effects based on a technical covariate (e.g., "tech").
#    - Harmony operates on PCA-reduced dimensions and stores corrected embeddings as "harmony_pca".
#
# 4. Dimensionality Reduction:
#    - Generate UMAP embedding based on Harmony-corrected PCA space.
#    - Store UMAP coordinates in Seurat object as "harmony_umap".
#
# 5. Nearest Neighbor Graphs:
#    - Construct kNN and SNN graphs using Harmony PCA space.
#    - These graphs are used as input for scICER clustering.
#
# 6. scICER Clustering:
#    - Perform bootstrapped clustering across a range of cluster numbers.
#    - Compute IC scores to assess consistency of clusters.
#    - Compute ECS scores to evaluate similarity to known cell types.
#
# 7. Optimal Cluster Selection:
#    - Select clusters with IC <= 1.005 and maximum ECS score.
#    - Assign robust cluster labels to Seurat object as "optimal_cluster".
#
# 8. Visualization:
#    - Generate four UMAP plots:
#       a) UMAP colored by batch/technology (default assay)
#       b) Harmony UMAP colored by batch/technology
#       c) Harmony UMAP colored by known cell types
#       d) Harmony UMAP colored by optimal scICER cluster
#    - Plots use default colors and remove background grids for clarity.
#
# 9. Output:
#    - Save combined UMAP plots and IC plot as PDF.
#    - Save ECS scores table as CSV.

library(Seurat)
library(ggplot2)
library(cowplot)
library(tidyverse)
library(mclust)
library(scICER)
library(doParallel)
library(SeuratDisk)
library(reticulate)
library(harmony)
library(qs)

# Use a specific Python environment (scanpy + pandas must be installed)
reticulate::use_python("/path/to/your/python/env/bin/python")
sc <- import("scanpy")
pd <- import("pandas")

# Input/Output
file_path <- "data/human_pancreas_example.h5ad"  # user-provided file
sample_name <- sub('\\.h5ad$', '', basename(file_path))
output_base_dir <- "results"
output_dir <- file.path(output_base_dir, sample_name)
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

# Load Seurat object (assumes conversion from h5ad done previously)
sample_obj <- qs::qread(file.path(output_dir, "seurat.sclens.qs"))

# Harmony integration
sample_obj <- RunHarmony(
  object = sample_obj,
  group.by.vars = "tech",
  reduction = "pca",
  dims.use = 1:dim(sample_obj@reductions$pca)[2],
  assay.use = "RNA",
  project.dim = FALSE,
  verbose = TRUE,
  reduction.save = "harmony_pca"
)

# UMAP embedding
sample_obj <- RunUMAP(
  object = sample_obj,
  dims = 1:dim(sample_obj@reductions$harmony_pca)[2],
  reduction = "harmony_pca",
  reduction.name = "harmony_umap",
  verbose = TRUE
)

# Nearest neighbor graphs
sample_obj <- FindNeighbors(
  object = sample_obj,
  reduction = "harmony_pca",
  dims = 1:dim(sample_obj@reductions$harmony_pca)[2],
  graph.name = c('harmony_nn','harmony_snn')
)

# DimPlot visualization with default colors
p1 <- DimPlot(sample_obj, reduction = "umap", group.by = "tech",
              pt.size = 3, alpha = 1, raster = TRUE, raster.dpi = c(1200,1200))

p2 <- DimPlot(sample_obj, reduction = "harmony_umap", group.by = "tech",
              pt.size = 3, alpha = 1, raster = TRUE, raster.dpi = c(1200,1200))

p_tech <- p1 + p2

# scICER clustering
scice_results <- scICE_clustering(
  object = sample_obj,
  cluster_range = 2:20,
  remove_threshold = Inf,
  n_workers = 8,
  n_trials = 30,
  n_bootstrap = 200,
  seed = 123,
  verbose = TRUE,
  graph_name = "harmony_snn"
)

# IC plot
ic_plot <- plot_ic(scice_results, threshold = 1.005, title = "Bootstrapped IC Dist", show_threshold = FALSE)
ic_plot$layers <- Filter(
  function(layer) !inherits(layer$geom, c("GeomPoint","GeomJitter","GeomText","GeomLabel")),
  ic_plot$layers
)
ic_plot$layers <- ic_plot$layers[!sapply(ic_plot$layers, is.null)]
p_ic <- ic_plot +
  theme_bw() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 1),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.ticks = element_line(color = "black"),
    axis.ticks.length = unit(-0.1, "cm"),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  scale_y_continuous(limits = c(NA, 1.15))

# Compute ECS scores
df_scores <- data.frame(
  cluster_number = scice_results$n_cluster,
  ic_score = scice_results$ic
)
df_scores$is_consistent <- df_scores$ic_score <= 1.005

sample_obj_df <- get_robust_labels(scice_results, return_seurat = FALSE, threshold = Inf)
sample_obj_df$celltype <- sample_obj@meta.data$celltype

for (k in 2:20) {
  cluster_col <- paste0("clusters_", k)
  if (cluster_col %in% names(sample_obj_df)) {
    ari_score <- element_sim(sample_obj_df$celltype, sample_obj_df[[cluster_col]])
    df_scores[df_scores$cluster_number == k, "ECS_score"] <- ari_score
  } else {
    warning(paste("Column", cluster_col, "does not exist in sample_obj_df"))
    df_scores[df_scores$cluster_number == k, "ECS_score"] <- NA
  }
}

# Determine optimal cluster
valid_clusters <- df_scores[df_scores$is_consistent, ]
if (nrow(valid_clusters) == 0) {
  stop("No clusters satisfy IC <= 1.005")
}
optimal_cluster <- valid_clusters$cluster_number[which.max(valid_clusters$ECS_score)]
cat("Optimal cluster selected:", optimal_cluster, "\n")

# Get robust cluster labels in Seurat object
sample_obj <- get_robust_labels(scice_results, return_seurat = TRUE, threshold = Inf)
cluster_col <- paste0("clusters_", optimal_cluster)
sample_obj$optimal_cluster <- sample_obj[[cluster_col]]

# Visualization: cell types and optimal cluster
p3 <- DimPlot(sample_obj, reduction = "harmony_umap", group.by = "celltype",
              pt.size = 3, alpha = 1, raster = TRUE, raster.dpi = c(1200,1200))

p4 <- DimPlot(sample_obj, reduction = "harmony_umap", group.by = "optimal_cluster",
              pt.size = 3, alpha = 1, raster = TRUE, raster.dpi = c(1200,1200))

p_all <- p1 / p2 / p3 / p4

# Save plots
ggsave(file.path(output_dir, paste0(sample_name, "_harmony_umap_plot.pdf")), 
       plot = p_all, width = 5, height = 30, dpi = 1200)

ggsave(file.path(output_dir, paste0(sample_name, "_IC_plot.pdf")),
       plot = p_ic, width = 3, height = 3)

# Save ECS score table
write.csv(df_scores, file.path(output_dir, paste0(sample_name, "_ECS_scores.csv")), row.names = FALSE)
